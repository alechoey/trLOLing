// this code is to analyze graph with weights computed from data if weight is provided

import org.apache.spark.graphx._
import org.apache.spark.graphx.lib._
import org.apache.spark.rdd.RDD

val data_path = "/home/saasbook/trLOLing/data/final/graphX/complete"
// read in the vertices and make vertex objects
val verts = sc.textFile(s"${data_path}/graphXChampionVertices.txt").map {l =>
  val lineSplits = l.split("\\s+")
  val id = lineSplits(0).trim.toLong
  val data = lineSplits.slice(1, lineSplits.length).mkString(" ")
  (id, data)
}
// read in the edges to make edge objects
val edge_lines = scala.io.Source.fromFile(s"${data_path}/graphXChampionEdges.txt").mkString.split('\n')
val buf = scala.collection.mutable.ArrayBuffer.empty[Edge[Int]]
edge_lines.foreach{(edge) => 
  val edge_info = edge.split(' ')
  buf+=Edge(edge_info(0).trim.toLong, edge_info(1).trim.toLong, edge_info(2).toInt)}
val edgeArray = buf.toArray
val edgeRDD: RDD[Edge[Int]] = sc.parallelize(edgeArray)
// finally make the graph object
val graph: Graph[String, Int] = Graph(verts, edgeRDD)
// look at triplets to calculate the in degree weight and outdegree weight
val vertice_values:collection.mutable.Map[Long, Double] = collection.mutable.Map()
var src = 0L
var dst = 0L
var value = 0L
val weight_edge_mapping = graph.triplets.map{t => Array(t.srcId, t.dstId, t.attr)}.toArray
weight_edge_mapping.foreach{(edge) =>
  src = edge(0)
  dst = edge(1)
  value = edge(2)
  if (vertice_values contains src) {
    vertice_values(src) += value
  }
  else {
    vertice_values.put(src, value)
  }
  if (vertice_values contains dst) {
    vertice_values(dst) -= value
  }
  else {
    vertice_values.put(dst, value*(-1))
  }
}

// compute average using degree information
val average_values:collection.mutable.Map[Long, Double] = collection.mutable.Map()

graph.degrees.toArray.foreach{case (id, deg) =>
  average_values.put(id, vertice_values(id)/(deg*1.0))
}

// filter out all the edges with degree 1


// make degree graph
case class TeamComp(name: String, inDeg: Int, outDeg: Int)

// Transform the graph
val userGraph = graph.mapVertices{ case (id, name) => TeamComp(name, 0, 0) }

// Fill in the degree information
val degreeGraph = userGraph.outerJoinVertices(userGraph.inDegrees) {
  (id, u, inDegOpt) => TeamComp(u.name, inDegOpt.getOrElse(0), u.outDeg)
}.outerJoinVertices(graph.outDegrees) {
  (id, u, outDegOpt) => TeamComp(u.name, u.inDeg, outDegOpt.getOrElse(0))
}
// filter out all the edges with all degree 4
val filtered_edges = degreeGraph.triplets.filter{case triplet => 
    triplet.dstAttr.inDeg > 1 || triplet.dstAttr.outDeg > 1 || triplet.srcAttr.inDeg > 1 || triplet.srcAttr.outDeg > 1}
val filter_edgeRDD = filtered_edges.map{ t =>  Edge(t.srcId, t.dstId, 1)}
filter_edgeRDD.saveAsTextFile(s"${data_path}/filteredAveragedChampionEdges")
val filter_vertRDD = degreeGraph.mapVertices{case (id, tc)=> (average_values(id), tc.inDeg, tc.outDeg)}.vertices.filter{case (id, (label, ind, outd)) => ind+outd > 1}.map{case (id, (label, ind, outd)) => (id, label)}
// incorporate average values to verts
val averaged_verts = verts.map{case (id, name) => 
  (id,average_values(id))}
averaged_verts.saveAsTextFile(s"${data_path}/averagedChampionVertices")
filter_edgeRDD.saveAsTextFile(s"${data_path}/unweightedChampionEdges")

/////////////////////////////////////////////////



// This code is to analyze graph with only win ratios
import org.apache.spark.graphx._
import org.apache.spark.graphx.lib._
import org.apache.spark.rdd.RDD

val data_path = "/home/saasbook/trLOLing/data/final/graphX/incomplete"
// read in the vertices and make vertex objects
val verts = sc.textFile(s"${data_path}/graphXChampionVertices.txt").map {l =>
  val lineSplits = l.split("\\s+")
  val id = lineSplits(0).trim.toLong
  val data = lineSplits.slice(1, lineSplits.length).mkString(" ")
  (id, data)
}

val edgeGraph = GraphLoader.edgeListFile(sc, s"${data_path}/graphXChampionEdges.txt")
val graph = edgeGraph.outerJoinVertices(verts)({ (vid, _, vinfo) => vinfo.getOrElse("xxxx")})
val outDegrees: VertexRDD[Int] = graph.outDegrees
// outDegree means won
// outDegrees.filter{case (id, indg) => indg>1}.foreach(println(_))
// look at losing teams
val inDegrees: VertexRDD[Int] = graph.inDegrees
// inDegrees.filter{case (id, indg) => indg>1}.foreach(println(_))
// find max
//graph.inDegrees.reduce{(a, b) => if (a._2>b._2) a else b}
//graph.outDegrees.reduce{(a, b) => if (a._2>b._2) a else b}

// make degree graph
case class TeamComp(name: String, inDeg: Int, outDeg: Int)

// Transform the graph
val userGraph = graph.mapVertices{ case (id, name) => TeamComp(name, 0, 0) }

// Fill in the degree information
val degreeGraph = userGraph.outerJoinVertices(userGraph.inDegrees) {
  (id, u, inDegOpt) => TeamComp(u.name, inDegOpt.getOrElse(0), u.outDeg)
}.outerJoinVertices(graph.outDegrees) {
  (id, u, outDegOpt) => TeamComp(u.name, u.inDeg, outDegOpt.getOrElse(0))
}
// filter out all the edges with all degree 4
val filtered_edges = degreeGraph.triplets.filter{case triplet => 
    triplet.dstAttr.inDeg > 4 || triplet.dstAttr.outDeg > 4 || triplet.srcAttr.inDeg > 4 || triplet.srcAttr.outDeg > 4}
val edgesArray = filtered_edges.map{ t =>  Edge(t.srcId, t.dstId, 1)}
edgeRDD.map{case (src, dst,weight) => (src, dst, 1)}.saveAsTextFile(s"${data_path}/filteredChampionEdges.csv")

// get the win rates
